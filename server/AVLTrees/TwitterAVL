const Twit = require(`twit`);
const fetch = require(`node-fetch`);
const Database = require(`../database/Database`);
const AvlTree = require(`avl`);
const Twitter_Following = require(`./Twitter_Following`);
const consumer_key = `GGXUovWNfvGvagGakjfTzDfe1`;
const consumer_secret = `UMG68Qym8K7vvsdtlEEIn0vRpyNj6Mfbmz6VUKMC3zn7tQNiat`;
const access_token = `1401939250858319875-zS8LTvSWz5UspdmaF63hxzpkLv0lbE`;
const access_secret_token = `YDEVhFyEMZuKPN1JAJeeyJPggOeeNVscl17PRXBOObKhP`;

const T = new Twit({
    consumer_key:         consumer_key,
    consumer_secret:      consumer_secret,
    access_token:         access_token,
    access_token_secret: access_secret_token, });

class TwitterAVL {
    #firestore_db;
    #tree;
    #following;
    #oembed_url = "https://publish.twitter.com/oembed"

    constructor(){
        this.#firestore_db = new Database().getInstance();
        this.#tree = new AvlTree();
        this.#following = new Twitter_Following(`alekarzeeshan92@gmail.com`).getInstance();
    }

    async getTweets() {
        this.#following.insert(`elonmusk`);
        const screen_names = this.#following.keys();
        if (screen_names.length > 0) {
            for (const name of screen_names) {
                T.get('statuses/user_timeline', {
                    screen_name: name,
                    count: 5,
                    exclude_replies: true
                }, async (error, data) => {
                    if(error)
                        return Promise.reject(error);
                    else{
                        for (const tweet of data){
                            const {text, id_str} = tweet;
                            this.#tree.insert(id_str, text);
                        }
                        console.log(`After for`)
                        await this.filterData(this.#following.getEmail());
                    }
                }).catch(error => {
                    return Promise.reject(error)
                });
            }
        }
    }

    async filterData(email) {

        const crypto_symbols = await this.#firestore_db.fetch(`Users`, email, `crypto`);
        const crypto_names = await this.#firestore_db.fetch(`Users`, email, `crypto_name`);
        const keys = this.#tree.keys();
        const values = this.#tree.values();
        let regex_string = "";

        for (const symbol of crypto_symbols)
            regex_string += `\\s${symbol}\\s|`

        for(const [index,name] of crypto_names.entries()) {
            if(index === crypto_names.length - 1)
                regex_string += name;
            else
                regex_string += `${name}|`;
        }

        const regex = new RegExp(regex_string, "gi");

        for (const [index,value] of values.entries()) {
            if(regex.exec(value) === null)
                this.#tree.remove(keys[index]);
        }
        
    }
}

class Singleton {

    constructor() {
        if (!Singleton.instance) {
            Singleton.instance = new TwitterAVL();
        }
    }

    getInstance() {
        return Singleton.instance;
    }
}

const singleton = new Singleton().getInstance();
singleton.getTweets().then();
module.exports = Singleton;