const Twit = require(`twit`);
const fetch = require(`node-fetch`);
const Database = require(`../database/Database`);
const AvlTree = require(`avl`);
const Twitter_Following = require(`./Twitter_Following`);
const consumer_key = `GGXUovWNfvGvagGakjfTzDfe1`;
const consumer_secret = `UMG68Qym8K7vvsdtlEEIn0vRpyNj6Mfbmz6VUKMC3zn7tQNiat`;
const access_token = `1401939250858319875-zS8LTvSWz5UspdmaF63hxzpkLv0lbE`;
const access_secret_token = `YDEVhFyEMZuKPN1JAJeeyJPggOeeNVscl17PRXBOObKhP`;

const T = new Twit({
    consumer_key:         consumer_key,
    consumer_secret:      consumer_secret,
    access_token:         access_token,
    access_token_secret: access_secret_token, });

class TwitterAVL {
    #firestore_db;
    #tree;
    #following;
    #oembed_url = "https://publish.twitter.com/oembed";
    #cryptocurrencies;

    constructor(){
        this.#firestore_db = new Database().getInstance();
        this.#tree = new AvlTree();
        this.#following = new Twitter_Following(`alekarzeeshan92@gmail.com`).getInstance();
        this.#cryptocurrencies = {}
    }

    async getTweets() {
        this.#following.insert(`MichaelSuppo`);
        const screen_names = this.#following.keys();
        if (screen_names.length > 0) {
            for (const name of screen_names) {
                T.get('statuses/user_timeline', {
                    screen_name: name,
                    count: 200,
                    exclude_replies: true
                }, async (error, data, response) => {
                    if(error)
                        return Promise.reject(error);
                    else{
                        for (const tweet of data){
                            const {text, id_str} = tweet;
                            if(this.#tree.find(id_str) === null)
                                this.#tree.insert(id_str, text);
                        }
                        await this.filterData(this.#following.getEmail());
                    }
                }).catch(error => {
                    return Promise.reject(error)
                });
            }
        }
    }

    async filterData(email) {

        const snapshot = await this.#firestore_db.fetch(`Users`);
        const docs = await snapshot.docs;
        const crypto = [];
        const crypto_name = [];
        let doc_crypto = null;
        let doc_crypto_name = null;
        let regex_string = "";
        const keys = this.#tree.keys();
        const values = this.#tree.values();

        for (const doc of docs){
            doc_crypto = doc.data().crypto;
            doc_crypto_name = doc.data().crypto_name;
            if(doc_crypto !== undefined)
                crypto.push(doc_crypto);
            if(doc_crypto_name !== undefined)
                crypto_name.push(doc_crypto_name);
        }

        for(const [outerIndex, symbols] of crypto.entries()){
            for(const [index, symbol] of symbols.entries()){
                if(!this.#cryptocurrencies.hasOwnProperty(symbol))
                    this.#cryptocurrencies[symbol] = crypto_name[outerIndex][index];
            }
        }

        for(const [index,[key, value]] of Object.entries(Object.entries(this.#cryptocurrencies))){
            if(parseInt(index) === Object.entries(this.#cryptocurrencies).length -1)
                regex_string += `\\s${key}\\s|` + `${value}`;
            else
                regex_string += `\\s${key}\\s|` + `${value}|`;
        }

        const regex = new RegExp(regex_string, "gi");

        for (const [index,value] of values.entries()) {
            if(regex.exec(value) === null)
                this.#tree.remove(keys[index]);
        }

    }
}

class Singleton {

    constructor() {
        if (!Singleton.instance) {
            Singleton.instance = new TwitterAVL();
        }
    }

    getInstance() {
        return Singleton.instance;
    }
}

const singleton = new Singleton().getInstance();
singleton.getTweets().then();
module.exports = Singleton;